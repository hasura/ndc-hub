/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Argument =
  | {
      name: string;
      type: "variable";
      [k: string]: unknown;
    }
  | {
      type: "literal";
      value: unknown;
      [k: string]: unknown;
    };
export type RelationshipArgument =
  | {
      name: string;
      type: "variable";
      [k: string]: unknown;
    }
  | {
      type: "literal";
      value: unknown;
      [k: string]: unknown;
    }
  | {
      name: string;
      type: "column";
      [k: string]: unknown;
    };
export type RelationshipType = "object" | "array";
export type Aggregate =
  | {
      /**
       * The column to apply the count aggregate function to
       */
      column: string;
      /**
       * Whether or not only distinct items should be counted
       */
      distinct: boolean;
      type: "column_count";
      [k: string]: unknown;
    }
  | {
      /**
       * The column to apply the aggregation function to
       */
      column: string;
      /**
       * Single column aggregate function name.
       */
      function: string;
      type: "single_column";
      [k: string]: unknown;
    }
  | {
      type: "star_count";
      [k: string]: unknown;
    };
export type Field =
  | {
      column: string;
      type: "column";
      [k: string]: unknown;
    }
  | {
      /**
       * Values to be provided to any collection arguments
       */
      arguments: {
        [k: string]: RelationshipArgument;
      };
      query: Query;
      /**
       * The name of the relationship to follow for the subquery
       */
      relationship: string;
      type: "relationship";
      [k: string]: unknown;
    };
export type OrderDirection = "asc" | "desc";
export type OrderByTarget =
  | {
      /**
       * The name of the column
       */
      name: string;
      /**
       * Any relationships to traverse to reach this column
       */
      path: PathElement[];
      type: "column";
      [k: string]: unknown;
    }
  | {
      /**
       * The column to apply the aggregation function to
       */
      column: string;
      /**
       * Single column aggregate function name.
       */
      function: string;
      /**
       * Non-empty collection of relationships to traverse
       */
      path: PathElement[];
      type: "single_column_aggregate";
      [k: string]: unknown;
    }
  | {
      /**
       * Non-empty collection of relationships to traverse
       */
      path: PathElement[];
      type: "star_count_aggregate";
      [k: string]: unknown;
    };
export type Expression =
  | {
      expressions: Expression[];
      type: "and";
      [k: string]: unknown;
    }
  | {
      expressions: Expression[];
      type: "or";
      [k: string]: unknown;
    }
  | {
      expression: Expression;
      type: "not";
      [k: string]: unknown;
    }
  | {
      column: ComparisonTarget;
      operator: UnaryComparisonOperator;
      type: "unary_comparison_operator";
      [k: string]: unknown;
    }
  | {
      column: ComparisonTarget;
      operator: BinaryComparisonOperator;
      type: "binary_comparison_operator";
      value: ComparisonValue;
      [k: string]: unknown;
    }
  | {
      column: ComparisonTarget;
      operator: BinaryArrayComparisonOperator;
      type: "binary_array_comparison_operator";
      values: ComparisonValue[];
      [k: string]: unknown;
    }
  | {
      in_collection: ExistsInCollection;
      type: "exists";
      where: Expression;
      [k: string]: unknown;
    };
export type ComparisonTarget =
  | {
      /**
       * The name of the column
       */
      name: string;
      /**
       * Any relationships to traverse to reach this column
       */
      path: PathElement[];
      type: "column";
      [k: string]: unknown;
    }
  | {
      /**
       * The name of the column
       */
      name: string;
      type: "root_collection_column";
      [k: string]: unknown;
    };
export type UnaryComparisonOperator = "is_null";
export type BinaryComparisonOperator =
  | {
      type: "equal";
      [k: string]: unknown;
    }
  | {
      name: string;
      type: "other";
      [k: string]: unknown;
    };
export type ComparisonValue =
  | {
      column: ComparisonTarget;
      type: "column";
      [k: string]: unknown;
    }
  | {
      type: "scalar";
      value: unknown;
      [k: string]: unknown;
    }
  | {
      name: string;
      type: "variable";
      [k: string]: unknown;
    };
export type BinaryArrayComparisonOperator = "in";
export type ExistsInCollection =
  | {
      /**
       * Values to be provided to any collection arguments
       */
      arguments: {
        [k: string]: RelationshipArgument;
      };
      relationship: string;
      type: "related";
      [k: string]: unknown;
    }
  | {
      /**
       * Values to be provided to any collection arguments
       */
      arguments: {
        [k: string]: RelationshipArgument;
      };
      /**
       * The name of a collection
       */
      collection: string;
      type: "unrelated";
      [k: string]: unknown;
    };

/**
 * This is the request body of the query POST endpoint
 */
export interface QueryRequest {
  /**
   * Values to be provided to any collection arguments
   */
  arguments: {
    [k: string]: Argument;
  };
  /**
   * The name of a collection
   */
  collection: string;
  /**
   * Any relationships between collections involved in the query request
   */
  collection_relationships: {
    [k: string]: Relationship;
  };
  /**
   * The query syntax tree
   */
  query: Query;
  /**
   * One set of named variables for each rowset to fetch. Each variable set should be subtituted in turn, and a fresh set of rows returned.
   */
  variables?:
    | {
        [k: string]: unknown;
      }[]
    | null;
  [k: string]: unknown;
}
export interface Relationship {
  /**
   * Values to be provided to any collection arguments
   */
  arguments: {
    [k: string]: RelationshipArgument;
  };
  /**
   * A mapping between columns on the source collection to columns on the target collection
   */
  column_mapping: {
    [k: string]: string;
  };
  relationship_type: RelationshipType;
  /**
   * The name of the collection or object type which is the source of this relationship
   */
  source_collection_or_type: string;
  /**
   * The name of a collection
   */
  target_collection: string;
  [k: string]: unknown;
}
export interface Query {
  /**
   * Aggregate fields of the query
   */
  aggregates?: {
    [k: string]: Aggregate;
  } | null;
  /**
   * Fields of the query
   */
  fields?: {
    [k: string]: Field;
  } | null;
  /**
   * Optionally limit to N results
   */
  limit?: number | null;
  /**
   * Optionally offset from the Nth result
   */
  offset?: number | null;
  order_by?: OrderBy | null;
  where?: Expression | null;
  [k: string]: unknown;
}
export interface OrderBy {
  /**
   * The elements to order by, in priority order
   */
  elements: OrderByElement[];
  [k: string]: unknown;
}
export interface OrderByElement {
  order_direction: OrderDirection;
  target: OrderByTarget;
  [k: string]: unknown;
}
export interface PathElement {
  /**
   * Values to be provided to any collection arguments
   */
  arguments: {
    [k: string]: RelationshipArgument;
  };
  /**
   * A predicate expression to apply to the target collection
   */
  predicate: Expression;
  /**
   * The name of the relationship to follow
   */
  relationship: string;
  [k: string]: unknown;
}
