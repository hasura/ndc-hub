package vulnerabilityscan

import (
    "os/exec"
    "fmt"
    "os"
    "syscall"
	"bytes"
	"log"

	"github.com/hasura/ndc-hub/registry-automation/pkg/ndchub"
)

func ScanArtifacts(artifacts *ndchub.ConnectorArtifacts) {
	for _, dockerImage := range artifacts.DockerImages {
		err := ScanImageWithTrivyDocker(dockerImage)
		if err != nil {
			fmt.Printf("error when scanning image %s: %s", dockerImage, err)
			os.Exit(1)
		}
	}

	err := ScanDirWithTrivyDocker(artifacts.ArtifactsDirPath)
	if err != nil {
		fmt.Printf("error when scanning directory %s: %s", artifacts.ArtifactsDirPath, err)
		os.Exit(1)
	}
}

func ScanImageWithTrivyDocker(dockerImage string) error {
	if dockerImage == "" {
		log.Printf("Docker image is empty, skipping Trivy scan for image.\n")
		return nil
	}

    log.Printf("Scanning docker image with trivy-docker: %s\n", dockerImage)
    args := []string{
			"run", "--rm",
			"-v", "/var/run/docker.sock:/var/run/docker.sock", // Needed to access Docker daemon
			"aquasec/trivy:latest",
			"image", 
			"--severity", "CRITICAL,HIGH",
            "--exit-code", "1", 
            "--no-progress", 
            "--format", "table", 
            dockerImage,
		}

	return scan(args...)
}

func ScanDirWithTrivyDocker(dirPath string) error {
	if dirPath == "" {
		log.Printf("Directory path is empty, skipping Trivy scan for directory.\n")
		return nil
	}

	log.Printf("Scanning file directory with trivy-docker: %s\n", dirPath)

	args := []string{
		"run", "--rm",
		"-v", fmt.Sprintf("%s:/target", dirPath), // Bind-mount the dir into /target inside the container
		"aquasec/trivy:latest",
		"fs", "/target",                          // Tell Trivy to scan the /target path
		"--exit-code", "1",                       // Exit with code 1 if any vuln is found
		"--no-progress",
		"--format", "table",
        "--scanners", "vuln,misconfig,secret,license",
		"--severity", "CRITICAL,HIGH",
	}

	return scan(args...)
}

func scan(args ...string) error {
    cmd := exec.Command("docker", args...)

    // Uncomment the following lines to capture output in a buffer
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	// Uncomment the following lines to capture output in os.stdout and os.stderr (terminal)
    // cmd.Stdout = os.Stdout
	// cmd.Stderr = os.Stderr

	log.Println("Running Trivy scan...")
	err := cmd.Run()

	if err != nil {
		// we'll only print the output if there was an error
		fmt.Println(out.String())
		if exitErr, ok := err.(*exec.ExitError); ok {
			code := exitErr.Sys().(syscall.WaitStatus).ExitStatus()
			fmt.Printf("Trivy exited with code: %d\n", code)
			if code == 1 {
				return fmt.Errorf("vulnerabilities found")
			}
			return fmt.Errorf("trivy failed with exit code %d", code)
		}
		return fmt.Errorf("trivy execution failed: %w", err)
	}

	log.Printf("Trivy scan completed successfully. No vulerabilites found\n")

	return nil
}