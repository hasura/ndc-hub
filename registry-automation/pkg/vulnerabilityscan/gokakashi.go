package vulnerabilityscan

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
)

// use this struct if you want to use gokakashi binary from a different path
type gokakashi struct {
	gokakashiBinaryPath string
}

func (g *gokakashi) notFoundError() error {
	if g.gokakashiBinaryPath == GokakashiBinaryPath {
		return fmt.Errorf("unable to find gokakashi \n\nDownload link: %s", gokakashiDownloadlLink)
	}
	return fmt.Errorf("unable to find gokakashi at %s \n\nDownload link: %s", g.gokakashiBinaryPath, gokakashiDownloadlLink)
}

const gokakashiDownloadlLink = "https://github.com/shinobistack/gokakashi/releases/latest/"

func UseCustomGokakashiBinaryPath(path string) *gokakashi {
	return &gokakashi{
		gokakashiBinaryPath: path,
	}
}

func GetDefaultGokakashiBin() *gokakashi {
	return &gokakashi{
		gokakashiBinaryPath: GokakashiBinaryPath,
	}
}

const GokakashiBinaryPath = "gokakashi"

func isGokakashiInstalled(gokakashi *gokakashi) bool {
	_, err := exec.LookPath(gokakashi.gokakashiBinaryPath)
	return err == nil
}

type GokakashiScanOptions struct {
	dockerImages         []string
	server               string
	token                string
	policy               string
	cfAccessClientId     string
	cfAccessClientSecret string
	gokakashi            *gokakashi
}

type GokakashiOption func(*GokakashiScanOptions)

func WithDockerImagesForScan(dockerImages []string) GokakashiOption {
	return func(opts *GokakashiScanOptions) {
		opts.dockerImages = dockerImages
	}
}

func WithServer(server string) GokakashiOption {
	return func(opts *GokakashiScanOptions) {
		opts.server = server
	}
}

func WithToken(token string) GokakashiOption {
	return func(opts *GokakashiScanOptions) {
		opts.token = token
	}
}

func WithPolicy(policy string) GokakashiOption {
	return func(opts *GokakashiScanOptions) {
		opts.policy = policy
	}
}

func WithCfAccessClientId(clientId string) GokakashiOption {
	return func(opts *GokakashiScanOptions) {
		opts.cfAccessClientId = clientId
	}
}

func WithCfAccessClientSecret(clientSecret string) GokakashiOption {
	return func(opts *GokakashiScanOptions) {
		opts.cfAccessClientSecret = clientSecret
	}
}

// returns the default Gokakashi binary if no path is provided, otherwise uses the custom path
func WithCustomBin(path string) GokakashiOption {
	var gokakashi *gokakashi = nil
	if path != "" {
		gokakashi = UseCustomGokakashiBinaryPath(path)
	}
	return func(opts *GokakashiScanOptions) {
		opts.gokakashi = gokakashi
	}
}

// scans docker images using Gokakashi
// the single error returned is for validation errors or other issues that prevent the scan from running
// the map returned contains errors for each image that failed to scan, with the image name as the key and the error as the value
func ScanDockerImageWithGokakashi(opts ...GokakashiOption) (map[string]error, error) {
	options := &GokakashiScanOptions{}
	gokakashi := GetDefaultGokakashiBin()
	for _, opt := range opts {
		opt(options)
	}

	errorMap := make(map[string]error)

	if len(options.dockerImages) == 0 {
		log.Printf("No Docker images provided for Gokakashi scan. Skipping scan.\n")
		return errorMap, nil
	}

	if options.server == "" {
		return errorMap, fmt.Errorf("server URL is required for Gokakashi scan")
	}

	if options.token == "" {
		return errorMap, fmt.Errorf("token is required for Gokakashi scan")
	}

	if options.policy == "" {
		return errorMap, fmt.Errorf("policy is required for Gokakashi scan")
	}

	if options.cfAccessClientId == "" {
		return errorMap, fmt.Errorf("cloudflare Access Client ID is required for Gokakashi scan")
	}

	if options.cfAccessClientSecret == "" {
		return errorMap, fmt.Errorf("cloudflare Access Client Secret is required for Gokakashi scan")
	}

	if options.gokakashi != nil {
		absPath, err := filepath.Abs(options.gokakashi.gokakashiBinaryPath)
		if err != nil {
			return errorMap, fmt.Errorf("error resolving path %s: %w", options.gokakashi.gokakashiBinaryPath, err)
		}
		gokakashi = options.gokakashi
		gokakashi.gokakashiBinaryPath = absPath
	}

	if !isGokakashiInstalled(gokakashi) {
		return errorMap, gokakashi.notFoundError()
	}

	for _, dockerImage := range options.dockerImages {
		log.Printf("Starting scan for image %s with gokakashi\n", dockerImage)
		if err := scanImageWithGokakashi(dockerImage, options); err != nil {
			errorMap[dockerImage] = fmt.Errorf("error scanning %s with Gokakashi: %w", dockerImage, err)
		}
	}

	return errorMap, nil
}

func scanImageWithGokakashi(dockerImage string, options *GokakashiScanOptions) error {
	args := []string{
		options.gokakashi.gokakashiBinaryPath,
		"scan", "image",
		"--image", dockerImage,
		"--server", options.server,
		"--token", options.token,
		"--policy", options.policy,
	}

	cmd := exec.Command(args[0], args[1:]...)
	cmd.Env = append(os.Environ(),
		fmt.Sprintf("CF_ACCESS_CLIENT_ID=%s", options.cfAccessClientId),
		fmt.Sprintf("CF_ACCESS_CLIENT_SECRET=%s", options.cfAccessClientSecret),
	)

	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	err := cmd.Run()
	fmt.Println(out.String())

	if err != nil {
		return fmt.Errorf("gokakashi error: %w\nOutput: %s", err, out.String())
	}

	return nil
}
